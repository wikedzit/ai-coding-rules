---
description: Follow these Rules when fixing a failing or broken test(s)
globs: 
alwaysApply: false
---

- These rules must be applied together with the project rules.
- Run the specified test (if no test is specified or not clear the ASK user to specify the test).
- Collect and do a deep Review of the output generated by the test.
- Tests are never the source of truth, they should therefore force the change to the codebase to reflect the test.
- Determine the part of the codebase that is causing the error.
- Please follow through the execution path to where the error is coming from to find out the exact file and line of code that is causing the error. 
e.g. Follow the endpoint that is called to the controller actions and then to the service then to the model and then to the migration.
- Determine the MOST relevant fix for the error at that point.
- Make sure that the part you are fixing follows the project rules including the file structure.
- Make sure the namespaces and imports are all done correctly.
- Check the migrations to establish and verify our table fields. Migration will always serve as the source of truth.
- Check the model to see if all fields and relationships are correctly defined based on the migration
- Do the same for Services, Request, Policy, Controller .etc
- Factories must be structured to reflect what we have in the migrations and model
- Fixing Tests MUST NEVER lead to creating any missing files.
- Never at any point change any migration rather update everything to keep the integrity of the migration and schema definitions.
- Do not create new migrations  or edit any existing migrations. If the field is not defined in the migration schemas it then means we have to stop referencing that field in the test and the codebase.
- Always refer to the current routes file (admin, API, and public) to see if the routes are correctly defined. 
- The best approach to RUN optimize: clear and route: list command to get the updated list of routes and their definitions.
- Tests should only use the routes that are defined in the routes file. 
- In case of a mismatch, the test should be updated to use the routes that are defined in the routes file. 
- Verify that policy is correctly defined, and checked and that the user has the correct permissions to access the routes.
- Make sure that the Policy code is well implemented and does the logic as expected instead of returning dummy values.
- Make sure that the Service code is well implemented and does the logic as expected instead of returning dummy values.
- Make sure that the Request code is well implemented and does the logic as expected instead of returning dummy values.
- Make sure that the Controller code is well implemented and does the logic as expected instead of returning dummy values.
- Make sure that the Model code is well implemented and does the logic as expected instead of returning dummy values.
- Make sure that the Factory code is well implemented and does the logic as expected instead of returning dummy values.
- Make sure that the Migration code is well implemented and does the logic as expected instead of returning dummy values.
- Make sure that if  Controller extends ApiController it then implements and follows what is defined in ApiController and should never change ApiController.
-INSERT debug statements (dd() or dump()) at specific sections of the test code  to help to capture possible errors at that section.
- Once the test passes, remove the debug statements.

RUN the previous tests again to confirm if the fixes have been applied.
